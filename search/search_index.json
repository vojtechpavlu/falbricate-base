{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Falbricate is a simple and lightweight ecosystem to Fabricate Falsa - to mock data by the specified schema.</p>"},{"location":"#about-project","title":"About project","text":"<p>The name chosen for this project is a composition of words Falsum and Fabricate - simply to indicate the intended purpose - to enable the user to generate any random data by declaring just how the output data should look like - by providing a simple JSON-like schema.</p> <p>This nature enables you to version the schema at the same pace the project needs will grow.</p> <p>Currently, its main aim is to enhance mocking and preparation tools; with future extension to other ecosystems to support the developer experience as much as possible.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>I believe every developer needs to focus on turning his awesome ideas into implementation, not to spend hours on preparing and updating his data base for testing the masterpiece.</p> <p>Motivation to build up this ecosystem is to provide the ability to create a data system in the easiest possible manner - for development and testing.</p>"},{"location":"Getting-Started/installation/","title":"Installation","text":""},{"location":"Getting-Started/installation/#requirements","title":"Requirements","text":"<p>This project is built on top of base Node.js with TypeScript and is meant primarily for Node-based applications with possible usage at static client-side applications with embedded JavaScript code.</p> <p>To remain as lightweight as possible, to use the base framework you only need to have virtually any JavaScript runtime environment - no matter if it's a Node.js or a page in your browser.</p> <p>If you choose to use any of the Falbricate Plugins, there might be some further requirements.</p>"},{"location":"Getting-Started/installation/#installation","title":"Installation","text":"<p>To install the base for this library, you only need to enter the following line into your command line:</p> <pre><code>npm install @falbricate/base\n</code></pre> <p>This gives you the base frame with basic functionality you can use to generate your falsa objects.</p>"},{"location":"Getting-Started/installation/#plugins","title":"Plugins","text":"<p>Currently, there are no plugins available yet, but I'm working on it!</p>"},{"location":"System-Documentation/00_introduction/","title":"Introduction","text":"<p>The whole ecosystem is based on various building blocks. This section aims on giving an introduction into them.</p>"},{"location":"System-Documentation/00_introduction/#fabrication-pipeline","title":"Fabrication Pipeline","text":"<p>Fabrication Pipeline represents the whole flow of the falsa generation - from loading and compiling of a given schema to generation of falsum objects.</p>"},{"location":"System-Documentation/00_introduction/#fabricator","title":"Fabricator","text":"<p>Fabricator is a base entrypoint to the whole fabrication ecosystem. This component is responsible for managing and maintaining of the whole falsa generation - fabrication pipeline.</p>"},{"location":"System-Documentation/00_introduction/#schema","title":"Schema","text":"<p>Schema is an internal representation of what the client described in his Schema Input provided to Fabricator and what is he expected to have at the end of the fabrication pipeline.</p>"},{"location":"System-Documentation/00_introduction/#schema-input","title":"Schema Input","text":"<p>Schema Input represents client given declaration of how should the generated falsa look like.</p> <p>This input is then compiled inside in the Fabricator into the actual Schema that is being used in the Fabrication Pipeline.</p>"},{"location":"System-Documentation/00_introduction/#value-generator","title":"Value Generator","text":"<p>Value generator is a component being able to generate a specific type of values. There are many kinds of them defined in the ecosystem; each using a different strategy and providing a different kind of value generation.</p> <p>Each Value Generator has its name assigned, so you can always refer to it by its name. You can also generate your own generators when you find yourself in situation of not finding any suitable solution. You can also register them to access your specifics whenever you need:</p> <pre><code>import { registerValueGenerator, get } from '@falbricate/base';\n\n// Registration of your custom Value Generator\nregisterValueGenerator(\n  'my-custom-generator',\n  (config: MyGeneratorConfig) =&gt; new MyGenerator(config),\n);\n\n// Accessing your Value Generator in code\nconst generator = getValueGenerator('my-custom-generator', {\n  requiredParam1: 'my-parameter',\n  requiredParam2: 123,\n});\n</code></pre>"},{"location":"System-Documentation/01_fabrication-pipeline/","title":"Fabrication Pipeline","text":"<p>Fabrication Pipeline represents the whole flow of the falsa generation.</p>"},{"location":"System-Documentation/Building-Blocks/01_schema/","title":"Schema","text":"<p>Schema represents an internal, abstract and somewhat \"proxy\" model of what is expected and what should be generated.</p> <p>Technically speaking, it's a compiled version of Schema Input, which is provided by the client.</p>"},{"location":"System-Documentation/Building-Blocks/01_schema/#internals","title":"Internals","text":"<p>Schema (as an instance of <code>Schema</code> class) consists of:</p> <ul> <li> <p>Fields Definition - which fields should be generated, what resources has to be used to provide values,   what values shall be generated for them and how these values expected to be modified. It not only uses   Value Generators for retrieving a value for the field name, it also pipes the value   through Value Pipes</p> </li> <li> <p>Falsum Pipes - pipes modifying the generated object by this schema (more on Falsum Pipes)</p> </li> <li> <p>Profiles - pregenerated values (uniquely for each falsum generation) being accessible from the value generators    to maintain the result Falsum within a given context. For example when you generate an object representing a    person born in Germany, the city of birth mustn't be Paris, his nationality will most likely remain german and    his name will probably be Hans. See more on Profiles.</p> </li> </ul>"},{"location":"System-Documentation/Building-Blocks/01_schema/#how-is-the-schema-used","title":"How is the Schema used","text":"<p>Schema is a root for <code>Fabricator</code> which uses it for Falsum fabrication. More on Fabricator</p>"},{"location":"System-Documentation/Building-Blocks/02_schema-input/","title":"Schema Input","text":"<p>Schema Input is an abstraction given by client which is being compiled by Fabricator into Schema - which is an internal representation of what the client expects to retrieve and how should the fabricated falsum look like.</p> <p>Similarly to Schema, the Schema Input also contains declarations of fields with Value Generators assigned.</p>"},{"location":"System-Documentation/Building-Blocks/02_schema-input/#schema-declaration","title":"Schema Declaration","text":"<p>The whole process of describing the schema via Schema Input was designed with a high emphasis on it's highly declarative nature - to enable the client to be able to declare everything with somewhat static description without any functional code.</p> <p>The reason for it is for example to be able to detach the schema into a separate static <code>.json</code> where the application could read the schema from (as the schema input), compile it internally and build falsa based on this model.</p> <p>For this purpose, there are many string shortcuts for common stuff you can use to describe \"what you want\" rather than \"how to achieve it\".</p>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/","title":"Value Generator","text":"<p>Value Generator provides a service to generate values the Falsum consists of. These generators are designed to be able to generate a random (or for example to simply pass predefined value from context) and return it. This service is used for generating a falsum by given schema.</p> <p>Every Value Generator is of type <code>ValueGenerator&lt;ValueType, Configuration&gt;</code> (internally predefined class). The constructor takes the configuration of type <code>Configuration</code> (which needs to be of type <code>ValueGeneratorConfig</code>). Then, the generator on its <code>get(context: GenerationContext)</code> method call returns a value of type <code>ValueType</code>.</p> <p>For example how can you use the generator, have a look on how to access the generator.</p>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/#accessing-value-generators","title":"Accessing Value Generators","text":"<p>Value generators are basically classes (or instances if you wish). It can be accessed as any other class instance you know.</p> <p>Example</p> <p>Accessing the generator as a class instance</p> <pre><code>const generator = new IntegerGenerator({ max: 17 });\nconst value = generator.generate();\n</code></pre> <p>But this is not the only way you can use these generators. The Falbricate ecosystem also enables you to access these generators from internal registry of generators - accessing by generator name.</p> <p>Tip</p> <p>It is highly recommended to refer to the Value Generators using their name, not to pass them directly.</p> <p>Example</p> <p>Accessing to the generator using registry</p> <pre><code>const generator = getValueGenerator('range-integer', { max: 17 });\nconst value = generator.get({});\n</code></pre>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/#configuration","title":"Configuration","text":"<p>Every Value Generator needs to be configured during its initialization. For this purpose, there's a mutual type defined looking like this:</p> <pre><code>export interface ValueGeneratorConfig {\n  /** Pipes to be used for modifying the generated value */\n  pipes?: ValuePipe[];\n\n  /** Description of how the nulls should be treated */\n  nullability?: NullabilityConfiguration;\n}\n</code></pre> <p>Each Value Generator Configuration consists of these two optional fields:</p> <ul> <li> <p><code>pipes</code> - Declares a list of Value Pipes for minor modifications of the generated value (   more at Introduction to Value Pipes)</p> </li> <li> <p><code>nullability</code> - Declares how should be null-like values treated. It means whether the fields   should or should not be empty values (more at Nullability)</p> </li> </ul>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/#custom-value-generators","title":"Custom Value Generators","text":"<p>You can find yourself the predefined value generators do not meet your requirements. Feel free to define your own Value Generators!</p>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/#creating-a-custom-generator","title":"Creating a custom generator","text":"<p>To create a Value Generator and to use it within the ecosystem, you need to follow simple rules:</p> <ol> <li>The generator needs to extend an abstract and generic class <code>ValueGenerator&lt;ValueType, Configuration&gt;</code></li> <li>Your configuration must be a superset of the <code>ValueGeneratorConfig</code> type</li> <li>(Optional) if you want to register your value generator, you must follow these instructions</li> </ol> <p>Example</p> <p>This example represents how you can create a random Star-rating value generator. The usecase of it is to generate a ratings like <code>n Stars</code>, while the <code>n</code> can be a number within a specified range; the expected result might look like <code>4 Stars</code> when given range <code>{ minStars: 1, maxStars: 5 }</code>.</p> <pre><code>    /** Configuration for the custom Value Generator extending the base config type */\n    type RatingGeneratorConfig = {\n      minStars: number,\n      maxStars: number\n    } &amp; ValueGeneratorConfig;\n\n\n    /** Custom generator providing the actual service of random value generation */\n    class RatingGenerator extends ValueGenerator&lt;string, RatingGeneratorConfig&gt;{\n\n      /** Constructor taking the configuration */\n      constructor(config: RatingGeneratorConfig) {\n        super(config)\n      }\n\n      /** Implementation of the actual generator */\n      get = (): string =&gt; {\n        const numberOfStars = randomInteger(this.config.minStars, this.config.maxStars);\n        return `${numberOfStars} Stars`\n      }\n    }\n\n\n    // Creating the instance of the Rating generator with specified configuration\n    const ratingGenerator = new RatingGenerator({\n      minStars: 1,\n      maxStars: 5\n    });\n\n    // Do something with the value\n    console.log(ratingGenerator.get())\n</code></pre>"},{"location":"System-Documentation/Building-Blocks/03_value-generator/#register-custom-value-generator","title":"Register Custom Value Generator","text":"<p>When you create your Custom Value Generator, you'll probably want it to be registered in the ecosystem (it is recommended approach anyway). Then, you can easily access it via the name you choose to use.</p> <p>Unique Naming</p> <p>Keep in mind the name you choose must be unique and can't collide with any already existing! When it does, the registration will throw an Error.</p> <p>Example</p> <pre><code>// Registration of your custom Value Generator\nregisterValueGenerator(\n    'my-star-rating-generator',\n    (config: RatingGeneratorConfig) =&gt; new RatingGenerator(config),\n);\n\n\n// Accessing your Value Generator in code\nconst generator = getValueGenerator('my-star-rating-generator', {\n    minStars: 1,\n    maxStars: 10\n});\n</code></pre>"},{"location":"System-Documentation/Building-Blocks/04_fabricator/","title":"Fabricator","text":"<p>Fabricator is an entity providing services of generating falsa objects by given schema. This servant maintains the whole Fabrication Pipeline.</p> <p>The Fabricator is a class taking only the Schema Input as a parameter, compiles it into internal Schema representation and provides the service of generating a single item (falsum) or multiple items (falsa) at once with its methods <code>generate(context)</code> and <code>generateMany(n, context)</code>.</p>"},{"location":"System-Documentation/Building-Blocks/04_fabricator/#example","title":"Example","text":"<pre><code>// Define the Schema Input consisting of a single field of `age`\n// which is expected to be an integer in range of [15, 85]\nconst schema = {\n  fields: {\n    age: {\n      type: 'range-integer',\n      config: {\n        min: 15,\n        max: 85,\n      },\n    },\n  },\n};\n\n// Create fabricator\nconst fabricator = new Fabricator(schema);\n\n// Generate 30 items\nconst falsa = fabricator.generateMany(30);\n\n// Do something with generated objects\nfalsa.forEach((falsum) =&gt; console.log(JSON.stringify(falsum)));\n</code></pre>"},{"location":"System-Documentation/Building-Blocks/05_context/","title":"Fabrication Context","text":"<p>Fabrication Context is a way to pass some additional information and further instructions related to the falsum being currently fabricated.</p> <p>Partially it's given by client, partially it's a context provided internally by the Fabricator.</p>"},{"location":"System-Documentation/Building-Blocks/05_context/#contents-of-the-context","title":"Contents of the Context","text":"<p>Context consists of multiple parts. First and the most important is the context the client provides. The client can put as the context whatever he might need for generation.</p> <p>For example have a look at Context Accessor.</p> <p>But there are also items added to the context internally:</p> <ul> <li> <p><code>index</code> - number of currently generated item in a row (counting from 0); more useful   when invoking <code>Fabricator#generateMany(n, context)</code> method</p> </li> <li> <p><code>current</code> - falsum being currently fabricated; useful when you need to access   other properties to stay consistent within falsum</p> </li> <li> <p><code>previous</code> - previously fabricated falsum; only populated when using   <code>Fabricator#generateMany(n, context)</code> method</p> </li> </ul> <p>Context overriding</p> <p>This two dimensions of the context (the client given and internally generated) are being merged giving the clinet the opportunity to alter the context as he wish and whenever he needs.</p> <p>On the other hand, be careful when doing so - you can easily get into unexpected behaviour just by overriding some of these default context properties!</p> <p>Example Context</p> <p>This is how the context might look like when passed to the Value Generator for the <code>email</code> field (when no client-given data are provided):</p> <pre><code>{\n    index: 37,\n    previous: {\n        id: 36,\n        username: 'alexander-the-great',\n        email: 'alexander@alexandria.io',\n        skills: ['horse riding', 'going to India']\n    },\n    current: {\n        id: 37,\n        username: 'genghis-khan'\n    }\n}\n</code></pre> <p>Note</p> <p>Note the <code>current</code> is being build in at the time the <code>email</code> is in the process of generation; keep in mind the order of the fields generation may influence the generated Falsum - when there are dependencies in between the fields</p> <p>Note</p> <p>Note the <code>previous</code> property is available only when generating multiple of falsa at once (using <code>generateMany</code> method); similarly it's for the <code>index</code> (for <code>generate</code> it remains always <code>0</code>)</p>"},{"location":"System-Documentation/Generators/00_introduction/","title":"Value Generators","text":"<p>Value Generators are one of the key components of the whole ecosystem. These units are responsible for generating values by the specified configuration - whether it's a random number within a given range or a list of complex nested objects.</p> <p>There are already many generators predefined and ready to use in the base framework - like for numbers, dates, strings, arrays, objects and many more.</p>"},{"location":"System-Documentation/Generators/00_introduction/#usage","title":"Usage","text":"<p>The recommended usage of Value Generators is within a static Schema Input, where you can declare such value.</p> <p>Example</p> <p>In here you can see a usage of Random Integer generator.</p> <pre><code>const schema: SchemaInput = {\n    fields: {\n        randomRating: {\n            type: 'range-integer',\n            config: {\n                min: 1,\n                max: 5\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ randomRating: 4 }\n</code></pre> <p>Anyway, you can use the generator as a standalone class by directly invoking the constructor or by requesting the generator by name. To show you all the alternatives, for each generator, there are always all this three example usages shown.</p>"},{"location":"System-Documentation/Generators/00_introduction/#value-pipes","title":"Value Pipes","text":"<p>Another features related to the value generators are Value Pipes used to manipulate the generated value to meet the required format.</p> <p>There are a set of predefined pipes you can use and you can use, you can also easily define and register your own when the predefined ones do not satisfy you fully.</p>"},{"location":"System-Documentation/Generators/00_introduction/#custom-value-generators","title":"Custom Value Generators","text":"<p>There are many reasons why to prepare your own generator, but usually it's because the value generation process might be too complex and too specific to achieve the desired values by your implementation rather than making hard-to-read schema.</p>"},{"location":"System-Documentation/Generators/00_introduction/#custom-configuration","title":"Custom configuration","text":"<p>First thing to consider is to have prepared possible configuration for such generator. This configuration must extend the specified parent declaration looking like this:</p> <pre><code>interface ValueGeneratorConfig {\n  /** Pipes to be used for modifying the generated value */\n  pipes?: (ValuePipe | string)[];\n\n  /** Description of how the nulls should be treated */\n  nullability?: NullabilityConfiguration;\n}\n</code></pre>"},{"location":"System-Documentation/Generators/00_introduction/#defining-value-generator","title":"Defining Value Generator","text":"<p>Every value generator is basically an object with the basic method  <code>get&lt;R extends GeneratedValue&gt;(context: FabricationContext) -&gt; R</code>.</p> <p>In other words, it generates a value of a specified type and optionally  can process a given context. No big deal.</p> <p>When you decide to use your custom configuration, you also should define your own constructor passing your configuration to the super class. It's the best practice  to validate the given values to match rules of your generation logic, or to define the assumed default configuration values.</p>"},{"location":"System-Documentation/Generators/00_introduction/#register-the-value-generator","title":"Register the Value generator","text":"<p>After you successfully pass through these steps, you can register your generator into the Falbricate ecosystem and use it in the declarative (schematic) manner.</p> <p>Note the name must be unique within all the other Value Generators.</p>"},{"location":"System-Documentation/Generators/00_introduction/#example","title":"Example","text":"<p>To show the whole example, let's have a look at Ratings generator.</p> <p>Example</p> <pre><code>/** \n * Configuration declaration for string-based ratings with unit\n */\nexport type CustomRatingsGeneratorConfig = {\n  includeZero: boolean;\n  rateUnitSingular?: string;\n  rateUnitPlural?: string;\n  max: number;\n} &amp; ValueGeneratorConfig;\n\n\n/** \n * Value Generator class declaration generating \n * a string-based rating with unit\n */\nexport class CustomRatingGeneratorConfig extends ValueGenerator&lt;\n  string,\n  CustomRatingsGeneratorConfig\n&gt; {\n\n  private readonly generator: IntegerGenerator;\n\n  constructor(config: CustomRatingsGeneratorConfig) {\n\n    // When any of these is empty, use default stars rating\n    if (!config.rateUnitSingular || !config.rateUnitPlural) {\n      config.rateUnitSingular = 'star';\n      config.rateUnitPlural = 'stars';\n    }\n\n    // When the max limit is not defined, throw an error\n    if (!config.max) {\n      throw new Error(`Property 'max' is required'`);\n    }\n\n    // Other checks you might find reasonable here...\n\n    // Build-up the parent object\n    super(config);\n\n    // Prepare a random number generator to make your life easier\n    this.generator = new IntegerGenerator({\n      min: config.includeZero ? 0 : 1,\n      max: config.max\n    });\n  };\n\n\n  /** \n   * Simple method deciding whether to use singular or plural \n   */\n  protected get = (): GeneratedValue =&gt; {\n    const rating: number = this.generator.generate();\n\n    // When the generated rating is zero\n    if (rating === 0) {\n      return `0 ${this.config.rateUnitPlural}`;\n    }\n\n    // When the generated rating is equal to 1\n    if (rating === 1) {\n      return `1 ${this.config.rateUnitSingular}`;\n    }\n\n    // Else (greater than 1)\n    return `${rating} ${this.config.rateUnitPlural}`;\n  };\n}\n</code></pre> <p>Now, you can register this Value Generator into the ecosystem.</p> <p>Example</p> <pre><code>registerValueGenerator(\n  'my-custom-rating-generator',\n  (config: CustomRatingsGeneratorConfig) =&gt; new CustomRatingGeneratorConfig(config),\n)\n</code></pre> <p>And the last step is to show how can this be used now!</p> <p>Example</p> <pre><code>const schema: SchemaInput = {\n    fields: {\n        starRatingWithZero: {\n            type: 'my-custom-rating-generator',\n            config: {\n                includeZero: true,\n                max: 5,\n            }\n        },\n        heartRatingWithoutZero: {\n            type: 'my-custom-rating-generator',\n            config: {\n                includeZero: false,\n                rateUnitSingular: 'heart',\n                rateUnitPlural: 'hearts',\n                max: 10\n            }\n        },\n        uppercasedStars: {\n            type: 'my-custom-rating-generator',\n            config: {\n                includeZero: true,\n                max: 5,\n\n                // Here we can use a Value Pipe to uppercase the result\n                pipes: ['uppercase']\n            }\n        }\n    }\n};\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{\n    starRatingWithZero: '0 stars',\n    heartRatingWithoutZero: '6 hearts',\n    uppercasedStars: '2 STARS'\n}\n</code></pre>"},{"location":"System-Documentation/Generators/01_numerics/","title":"Number generators","text":"<p>Here is a list of predefined generators for generating numeric values.</p>"},{"location":"System-Documentation/Generators/01_numerics/#random-integer","title":"Random Integer","text":"<p>Random integer generator returns a number in a specified range.</p> <p>Configuration fields are <code>min</code> and <code>max</code>, while <code>min</code> is optional; when not provided, the default minimum value will be used (<code>0</code>).</p> <p>Throws an error when <code>min</code> &gt; <code>max</code> or when <code>max</code> is not provided.</p>"},{"location":"System-Documentation/Generators/01_numerics/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: IntegerGeneratorConfig = {\n    min: 13,\n    max: 77\n}\n\nconst generator = new IntegerGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>39\n</code></pre> <pre><code>const config: IntegerGeneratorConfig = {\n    min: 13,\n    max: 77\n}\n\nconst generator = getValueGenerator('range-integer', config);\n\nconst value = generator.get({});\n</code></pre> <p>Output</p> <pre><code>39\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'range-integer',\n            config: {\n                min: 13,\n                max: 77\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 39 }\n</code></pre>"},{"location":"System-Documentation/Generators/01_numerics/#random-float","title":"Random Float","text":"<p>Random float generator returns a number in a specified range with stripping the number of decimal digits to specified number. Of course, this is a maximum number of digits, in the most extreme situation, it might end up with returning an integer - when all the decimal digits are zeros.</p> <p>Configuration fields are <code>min</code>, <code>max</code> and <code>decimalDigits</code>. Fields <code>min</code> and <code>decimalDigits</code> are optional:</p> <ul> <li>when <code>min</code> not provided, it uses <code>min: 0</code>.</li> <li>when <code>decimalDigits</code> not provided, it uses <code>decimalDigits: 2</code>.</li> </ul> <p>It throws an error when <code>min</code> &gt; <code>max</code>, when <code>max</code> is not provided or when the <code>decimalDigits</code> is negative.</p>"},{"location":"System-Documentation/Generators/01_numerics/#examples_1","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: FloatGeneratorConfig = {\n    min: 13,\n    max: 77,\n    decimalDigits: 7\n}\n\nconst generator = new FloatGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>67.4635403\n</code></pre> <pre><code>const config: FloatGeneratorConfig = {\n    min: 13,\n    max: 77,\n    decimalDigits: 7\n}\n\nconst generator = getValueGenerator('range-float', config);\n\nconsole.log(generator.get({}));\n</code></pre> <p>Output</p> <pre><code>67.4635403\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'range-float',\n            config: {\n                min: 13,\n                max: 77,\n                decimalDigits: 7\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 67.4635403 }\n</code></pre>"},{"location":"System-Documentation/Generators/02_strings/","title":"String generators","text":"<p>Here is a list of predefined generators for generating string values.</p> <p>Note</p> <p>These generators are well combined with Charsets feature  </p>"},{"location":"System-Documentation/Generators/02_strings/#random-string-of-lenght","title":"Random String of lenght","text":"<p>Generates a random string based on desired <code>length</code> (number) and given <code>charset</code>.</p> <p><code>charset</code> is checked to be a real Charset. When it's not, it throws an error; so it does when the <code>length</code> is negative. Both fields are required.</p>"},{"location":"System-Documentation/Generators/02_strings/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: StringGeneratorConfig = {\n    length: 13,\n    charset: ['a', 'b', 'c', 'd']\n}\n\nconst generator = new StringOfLengthGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>bccbdaddacdbd\n</code></pre> <pre><code>const config: StringGeneratorConfig = {\n    length: 13,\n    charset: ['a', 'b', 'c', 'd']\n}\n\nconst generator = getValueGenerator('string-of-length', config);\n\nconst value = generator.generate();\n</code></pre> <p>Output</p> <pre><code>bccbdaddacdbd\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'string-of-length',\n            config: {\n                length: 13,\n                charset: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'bccbdaddacdbd' }\n</code></pre>"},{"location":"System-Documentation/Generators/02_strings/#random-string","title":"Random String","text":"<p>Generates a random string based on a given <code>charset</code> with length within a specified range.</p>"},{"location":"System-Documentation/Generators/02_strings/#configuration","title":"Configuration","text":"<p>This Value Generator requires configuration describing the attributes of the desired string looking as follows:</p> Configuration definitionExample <p>This configuration requires a specification of the length as a range withing which the output string should be of, and a set of characters the result string should consist of:</p> <pre><code>export type RandomStringGeneratorConfig = {\n    minLen?: number;\n    maxLen: number;\n    charset: Charset;\n} &amp; ValueGeneratorConfig;\n</code></pre> <p>The following configuration example could be used to generate strings of length somewhere in between 0 and 15 characters while using only characters of the set <code>['a', 'b', 'c', 'd', 'e', 'f']</code></p> <pre><code>const config: RandomStringGeneratorConfig = {\n    maxLen: 15,\n    charset: ['a', 'b', 'c', 'd', 'e', 'f']\n};\n</code></pre> <p>There are some general rules applied to the configuration being checked:</p> <ul> <li>Property <code>minLen</code> is optional. When not provided, zero (<code>0</code>) is used.</li> <li>Property <code>maxLen</code> is required.</li> <li><code>minLen</code> must not be greater then <code>maxLen</code>.</li> <li>Both <code>minLen</code> and <code>maxLen</code> must be positive numbers.</li> <li><code>charset</code> is checked to be a real Charset.</li> </ul>"},{"location":"System-Documentation/Generators/02_strings/#examples_1","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: RandomStringGeneratorConfig = {\n    maxLen: 15,\n    charset: ['a', 'b', 'c', 'd', 'e', 'f']\n};\n\nconst generator = new RandomStringGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'acafbedcaf'\n</code></pre> <pre><code>const config: RandomStringGeneratorConfig = {\n    maxLen: 15,\n    charset: ['a', 'b', 'c', 'd', 'e', 'f']\n};\n\nconst generator = getValueGenerator('random-string', config);\n\nconst value = generator.generate();\n</code></pre> <p>Output</p> <pre><code>'acafbedcaf'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'random-string',\n            config: {\n                maxLen: 15,\n                charset: ['a', 'b', 'c', 'd', 'e', 'f']\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'acafbedcaf' }\n</code></pre>"},{"location":"System-Documentation/Generators/02_strings/#string-template","title":"String template","text":"<p>This Value Generator is a template String processor. It lets you generate any string you desire by the specified template that is being filled up during the generation.</p>"},{"location":"System-Documentation/Generators/02_strings/#configuration_1","title":"Configuration","text":"Configuration definitionExample <pre><code>// Declaration of variables with values being generated\nexport interface StringTemplateVariables {\n    [variable: string]: (\n        // This is a description of schema fields in declarative manner\n        DeclarativeFieldDefinition |\n\n        // Or, you can pass the Value Generator directly as an instance\n        ValueGenerator&lt;GeneratedValue, ValueGeneratorConfig&gt;\n    );\n}\n\n// Declaration of custom charsets assigned to tags - you can use\n// these tags in your template string and these will be then replaced\n// with a random character from the specified set of characters\nexport interface CustomCharsets {\n    [tag: string]: Charset\n}\n\n// The root configuration declaration\nexport type StringTemplateGeneratorConfig = {\n    template: string;\n    variables?: StringTemplateVariables;\n    customCharsets?: CustomCharsets;\n} &amp; ValueGeneratorConfig;\n</code></pre> <p>The following configuration example could be used to generate strings of length somewhere in between 0 and 15 characters while using only characters of the set <code>['a', 'b', 'c', 'd', 'e', 'f']</code></p> <pre><code>const config: StringTemplateGeneratorConfig = {\n    template: 'ID-{foo}-{foo}-{bar}-%c%c%C%C-%D%d-%x%x',\n    variables: {\n        foo: {\n            type: 'constant-value',\n            config: {\n                value: 'foo_value'\n            }\n        },\n        bar: {\n            type: 'constant-value',\n            config: {\n                value: 'bar_value'\n            }\n        },\n    },\n    customCharsets: {\n        '%x': ['x', 'y', 'z']\n    }\n}\n</code></pre> <p>Expected Output</p> <p>Expected output of such complex configuration could look something like this:</p> <pre><code>'ID-foo_value-foo_value-bar_value-dvUT-73-zx'\n</code></pre>"},{"location":"System-Documentation/Generators/02_strings/#variables","title":"Variables","text":"<p>Handling variables is one of the basic template features supported. The variable substitution is split into two steps:</p> <ul> <li> <p>Value Generation - To generate a value being used in the final string, you need to provide   the desired Value Generator. You can use for example a Random String generator, Random Number generator   or Context Accessor; the only requirement is to be actually a Value generator. Then, when this Template   String Generator is requested for template generation, it will always generate new values for this   provisioning. Keep in mind that this value is being reused during the whole single generation.</p> </li> <li> <p>Replacement - To replace the generated value in the template, you use a specific syntax to tell the   Template generator where to put the value to - using <code>{variableName}</code>. The whole substring with brackets   is then replaced with the actual value prepared by the generator specified by the <code>variableName</code>.</p> </li> </ul> <p>This generator is very useful for generating random strings of a specific form. But it can also be used also (as noted above) to generate strings with placeholders - variables.</p> <p>It always follows this scenario:</p> <p>Example</p> <pre><code>const config = {\n    template: '&lt;&lt; string template using {variable_name} as input &gt;&gt;',\n    variables: {\n        variable_name: {\n            // Value Generator declaration\n        }\n    }\n}\n</code></pre>"},{"location":"System-Documentation/Generators/02_strings/#custom-charsets","title":"Custom Charsets","text":"<p>Custom charsets is another feature enabling the client to use a custom set of characters at a specific place in the template.</p> <p>By defining the tag and assigning the desired Charset, the Value Generator seeks these tags in the template and substitutes it with a randomly selected character.</p> <p>You can specify those in an optional <code>customCharsets</code> property.</p>"},{"location":"System-Documentation/Generators/02_strings/#predefined-charsets","title":"Predefined Charsets","text":"<p>The most basic feature of the String Template Generator is the ability to use common character sets.</p> <ul> <li><code>%d</code> describes any digit in range <code>[0, 9]</code></li> <li><code>%D</code> describes any digit in range <code>[1, 9]</code> (can be useful when want a set of digits to not   start with a zero)</li> <li><code>%c</code> describes any lowercase alphabetic character (like <code>[a-z]</code> regular expression)</li> <li><code>%C</code> describes any uppercase alphabetic character (like <code>[A-Z]</code> regular expression)</li> </ul>"},{"location":"System-Documentation/Generators/02_strings/#examples_2","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>// Configuration of the String builder\nconst config: StringTemplateGeneratorConfig = {\n    template: 'UID_{userIdFromContext}-%userClass-item-%D%d%d%d%d%d',\n    variables: {\n        userIdFromContext: {\n            type: 'context-input',\n            config: {\n                path: 'userId'\n            }\n        }\n    },\n    customCharsets: {\n        '%userClass': ['a', 'x', 'r', 'w']\n    }\n};\n\n// Generator using the given configuration\nconst generator = new StringTemplateGenerator(config);\n\n// Context passing the userId\nconst context: FabricationContext = {\n    userId: 123456789\n}\n\nconsole.log(generator.generate(context));\n</code></pre> <p>Output</p> <pre><code>'UID_123456789-r-item-203571'\n</code></pre> <pre><code>// Configuration of the String builder\nconst config: StringTemplateGeneratorConfig = {\n    template: 'UID_{userIdFromContext}-%userClass-item-%D%d%d%d%d%d',\n    variables: {\n        userIdFromContext: {\n            type: 'context-input',\n            config: {\n                path: 'userId'\n            }\n        }\n    },\n    customCharsets: {\n        '%userClass': ['a', 'x', 'r', 'w']\n    }\n};\n\n// Generator using the given configuration\nconst generator = getValueGenerator('string-template', config);\n\n// Context passing the userId\nconst context: FabricationContext = {\n    userId: 123456789\n}\n\nconsole.log(generator.generate(context));\n</code></pre> <p>Output</p> <pre><code>'UID_123456789-r-item-203571'\n</code></pre> <pre><code>const schema: SchemaInput = {\n  fields: {\n    userItemId: {\n      type: 'string-template',\n      config: {\n        template: 'UID_{userIdFromContext}-%userClass-item-%D%d%d%d%d%d',\n        variables: {\n          userIdFromContext: {\n            type: 'context-input',\n            config: {\n              path: 'userId'\n            }\n          }\n        },\n        customCharsets: {\n          '%userClass': ['a', 'x', 'r', 'w']\n        }\n      }\n    }\n  }\n}\n\n// Fabricator generating Falsa of such shape\nconst fabricator = new Fabricator(schema);\n\n// Context passing the userId\nconst context: FabricationContext = {\n    userId: 123456789\n}\n\nconsole.log(fabricator.generate(context));\n</code></pre> <p>Output</p> <pre><code>{ userItemId: 'UID_123456789-r-item-203571' }\n</code></pre>"},{"location":"System-Documentation/Generators/03_booleans/","title":"Boolean generators","text":"<p>Here is a list of predefined generators for generating boolean values.</p>"},{"location":"System-Documentation/Generators/03_booleans/#probable-boolean","title":"Probable boolean","text":"<p>Aims to generating boolean values considering a given probability. This specified probability has a direct influence on if the generated value will be <code>true</code> or <code>false</code>.</p> <p>The optional configuration field <code>probability</code> is expected to be a number in range of <code>[0, 1]</code>, while the higher the value is, the more probable is that <code>true</code> will be generated. When not provided at all, it uses <code>0.5</code> (probabilities for <code>true</code> and <code>false</code> are equal).</p>"},{"location":"System-Documentation/Generators/03_booleans/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: BooleanGeneratorConfig = {\n    probability: 0.7\n}\n\nconst generator = new ProbableBooleanGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>true\n</code></pre> <pre><code>const config: BooleanGeneratorConfig = {\n    probability: 0.7\n}\n\nconst generator = getValueGenerator('probable-boolean', config);\n\nconst value = generator.get({});\n</code></pre> <p>Output</p> <pre><code>true\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'probable-boolean',\n            config: {\n                probability: 0.7\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: true }\n</code></pre>"},{"location":"System-Documentation/Generators/04_dates/","title":"Date generators","text":"<p>Here are listed predefined date generators.</p>"},{"location":"System-Documentation/Generators/04_dates/#date-in-range","title":"Date in range","text":"<p>This generator generates dates within a specified range.</p>"},{"location":"System-Documentation/Generators/04_dates/#configuration","title":"Configuration","text":"<p>Keep in mind the <code>DateTimeDeclaration</code> is a specific type to ease the bounds definition in the configuration. Have a look on these examples:</p> Date objectString-based dateNumber-based date (Timestamp) <p>Declaring the date as number</p> <pre><code>// Using a date object\nconst declaration: DateTimeDeclaration = new Date();\n</code></pre> <pre><code>// Using string-based declaration of date\nconst declaration1: DateTimeDeclaration = '1999-12-31';\n\n// Using string-based declaration of date and time without ms\nconst declaration2: DateTimeDeclaration = '1999-12-31T11:25:31';\n\n// Using string-based declaration of date and time with ms\nconst declaration3: DateTimeDeclaration = '1999-12-31T11:25:31.975';\n</code></pre> <pre><code>// Using number-based declaration of date (1970-01-01 at midnight)\nconst declaration1: DateTimeDeclaration = 0;\n\n// Using number-based declaration of date (2014-09-12 at 23:52:25)\nconst declaration2: DateTimeDeclaration = 1413157945123;\n\n// Using number-based declaration of date (1925-03-22 at 00:07:35)\nconst declaration2: DateTimeDeclaration = -1413157945123;\n</code></pre> <p>Here you can see how to define the whole configuration:</p> Configuration definitionConfiguration example <pre><code>export type DateTimeInRangeGeneratorConfig = {\n  from: DateTimeDeclaration;\n  to: DateTimeDeclaration;\n} &amp; ValueGeneratorConfig;\n</code></pre> <pre><code>const config: DateTimeInRangeGeneratorConfig = {\n  from: '1999-12-31T11:25:31.975',\n  to: 1413157945123\n};\n</code></pre>"},{"location":"System-Documentation/Generators/04_dates/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: DateTimeInRangeGeneratorConfig = {\n  from: '1999-12-31T11:25:31.975',\n  to: 1413157945123\n};\n\nconst generator = new DateTimeInRangeGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>2006-01-17T09:42:39.858Z\n</code></pre> <pre><code>const config: DateTimeInRangeGeneratorConfig = {\n  from: '1999-12-31T11:25:31.975',\n  to: 1413157945123\n};\n\nconst generator = getValueGenerator('range-date-time', config);\n\nconst value = generator.get({});\n</code></pre> <p>Output</p> <pre><code>2006-01-17T09:42:39.858Z\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'range-date-time',\n            config: {\n              from: '1999-12-31T11:25:31.975',\n              to: 1413157945123\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 2006-01-17T09:42:39.858Z }\n</code></pre>"},{"location":"System-Documentation/Generators/05_arrays/","title":"Array generators","text":"<p>Here is a list of predefined generators for generating array values.</p>"},{"location":"System-Documentation/Generators/05_arrays/#array-picker","title":"Array Picker","text":"<p>Returns a value by randomly selecting an item from the specified array in the configuration.</p> <p>The <code>array</code> field can be an array of any type; the only restriction is it needs to be at least one item long.</p>"},{"location":"System-Documentation/Generators/05_arrays/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: ArrayPickerConfig = {\n    array: ['a', 'b', 'c', 'd']\n}\n\nconst generator = new ArrayPicker(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>a\n</code></pre> <pre><code>const config: ArrayPickerConfig = {\n    array: ['a', 'b', 'c', 'd']\n}\n\nconst generator = getValueGenerator('array-picker', config);\n\nconst value = generator.get({});\n</code></pre> <p>Output</p> <pre><code>a\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-picker',\n            config: {\n                array: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'a' }\n</code></pre>"},{"location":"System-Documentation/Generators/05_arrays/#array-sample","title":"Array Sample","text":"<p>This generator creates a deep copy of the specified array and returns a shuffled sample of it.</p> <p>It takes <code>array</code> field as a non-empty array of items of any type and the <code>sampleSize</code> which is any integer number greater than 0.</p> <p>When these requirements are not met, it throws an error; so it does when the sample size is greater than the length of the given array.</p>"},{"location":"System-Documentation/Generators/05_arrays/#examples_1","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: ArraySampleConfig = {\n    array: ['a', 'b', 'c', 'd'],\n    sampleSize: 2\n}\n\nconst generator = new ArraySampleGenerator(config);\n\nconsole.log(generator.get({}));\n</code></pre> <p>Output</p> <pre><code>[ 'd', 'b' ]\n</code></pre> <pre><code>const config: ArraySampleConfig = {\n    array: ['a', 'b', 'c', 'd'],\n    sampleSize: 2\n}\n\nconst generator = getValueGenerator('array-sample', config);\n\nconsole.log(generator.get({}));\n</code></pre> <p>Output</p> <pre><code>[ 'd', 'b' ]\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-sample',\n            config: {\n                array: ['a', 'b', 'c', 'd'],\n                sampleSize: 2\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: [ 'd', 'b' ] }\n</code></pre>"},{"location":"System-Documentation/Generators/06_objects/","title":"Object generators","text":"<p>Here is a list of predefined generators for generating object values.</p>"},{"location":"System-Documentation/Generators/06_objects/#object-from-schema","title":"Object from Schema","text":"<p>Builds up an object by given schema.</p> <p>The configuration object is required to have <code>schema</code> field containing a Schema Input object. This configured schema object will be used to generate nested falsum.</p>"},{"location":"System-Documentation/Generators/06_objects/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-picker',\n            config: {\n                array: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst generator = new ObjectFromSchemaGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'd' }\n</code></pre> <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-picker',\n            config: {\n                array: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst config: ObjectFromSchemaConfig = {\n    schema: fieldSchema\n}\n\nconst generator = getValueGenerator('object-from-schema', config);\n\nconst value = generator.generate();\n</code></pre> <p>Output</p> <pre><code>{ value: 'd' }\n</code></pre> <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-picker',\n            config: {\n                array: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst schema: SchemaInput = {\n    fields: {\n        nested: {\n            type: 'object-from-schema',\n            config: {\n                schema: fieldSchema\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ nested: { value: 'd' } }\n</code></pre>"},{"location":"System-Documentation/Generators/06_objects/#list-of-objects-from-schema","title":"List of Objects from Schema","text":"<p>Builds up a list of objects by given schema.</p> <p>The configuration object is required to have <code>schema</code> field containing a Schema Input object. This configured schema object will be used to generate nested falsum.</p> <p>It also expects field <code>n</code> describing how many items should it generate.</p>"},{"location":"System-Documentation/Generators/06_objects/#examples_1","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: ListOfObjectsFromSchemaConfig = {\n    n: 3,\n    schema: {\n        fields: {\n            testField1: {\n                type: \"constant-value\",\n                config: {\n                    value: \"testValue\"\n                }\n            },\n            testField2: {\n                type: \"constant-value\",\n                config: {\n                    value: \"testValue\"\n                }\n            }\n        }\n    }\n}\n\nconst generator = new ListOfObjectsFromSchemaGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>[\n    { testField1: 'testValue', testField2: 'testValue' },\n    { testField1: 'testValue', testField2: 'testValue' },\n    { testField1: 'testValue', testField2: 'testValue' }\n]\n</code></pre> <pre><code>const config: ListOfObjectsFromSchemaConfig = {\n    n: 3,\n    schema: {\n        fields: {\n            testField1: {\n                type: \"constant-value\",\n                config: {\n                    value: \"testValue\"\n                }\n            },\n            testField2: {\n                type: \"constant-value\",\n                config: {\n                    value: \"testValue\"\n                }\n            }\n        }\n    }\n}\n\nconst generator = getValueGenerator('list-of-schema', config);\n\nconst value = generator.generate();\n</code></pre> <p>Output</p> <pre><code>[\n    { testField1: 'testValue', testField2: 'testValue' },\n    { testField1: 'testValue', testField2: 'testValue' },\n    { testField1: 'testValue', testField2: 'testValue' }\n]\n</code></pre> <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'array-picker',\n            config: {\n                array: ['a', 'b', 'c', 'd']\n            }\n        }\n    }\n}\n\nconst schema: SchemaInput = {\n    fields: {\n        nested: {\n            type: 'list-of-schema',\n            config: {\n                n: 5,\n                schema: fieldSchema\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{\n    nested: [\n        { value: 'a' },\n        { value: 'c' },\n        { value: 'c' },\n        { value: 'b' },\n        { value: 'a' }\n    ]\n}\n</code></pre>"},{"location":"System-Documentation/Generators/07_contextuals/","title":"Contextuals","text":"<p>Here is a list of predefined generators retrieving values from Fabrication Context.</p>"},{"location":"System-Documentation/Generators/07_contextuals/#context-accessor","title":"Context Accessor","text":"<p>Returns a value from the received context. The value is reached by the given path the value is expected to be at.</p> Configuration DeclarationConfiguration Example <p>The configuration is a bit more complex for this type of generator. Its declaration looks like this:</p> <pre><code>export type ContextAccessorConfig = {\n  path: string;\n  sep?: PathSeparator;\n  handleError?: boolean;\n  useErrorValue?: any;\n} &amp; ValueGeneratorConfig;\n</code></pre> <p>This configuration tries to access the data provided externally by the client, while accessing object <code>person</code> and taking the property <code>email</code>. When for example you forget to provide the person, it won't struggle with accessing proeprties of <code>undefined</code>, it simply returns <code>undefined</code> without error.</p> <pre><code>const config: ContextAccessorConfig = {\n  path: \"person/email\";\n  sep: \"/\";\n  handleError: true;\n  useErrorValue: undefined;\n};\n</code></pre> <ul> <li> <p><code>path</code> represents the path in the given fabrication context (like <code>profiles.identifiers.uuid</code>)</p> </li> <li> <p><code>sep</code> represents separator to be used on path; by default it's a dot (<code>.</code>); supported   values are <code>.</code>, <code>/</code>, <code>#</code> and <code>$</code></p> </li> <li> <p><code>handleError</code> tells the accessor that if there is no value on the path or when it comes into another   issue, if it should try to handle or should fail in the first place. By default, it lets the error   to be thrown. Otherwise, it uses null-like value specified in <code>useErrorValue</code></p> </li> <li> <p><code>useErrorValue</code> value to be used when an error occurs (the recommended option is using <code>undefined</code>)</p> </li> </ul>"},{"location":"System-Documentation/Generators/07_contextuals/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: ContextAccessorConfig = {\n    path: 'input.value',\n    sep: '.'\n}\n\nconst generator = new ContextAccessor(config);\n\nconst context: FabricationContext = {\n    input: {\n        value: \"Value given from outside\"\n    }\n}\n\nconsole.log(generator.generate(context));\n</code></pre> <p>Output</p> <pre><code>Value given from outside\n</code></pre> <pre><code>const config: ContextAccessorConfig = {\n    path: 'input.value',\n    sep: '.'\n}\n\nconst generator = getValueGenerator('context-input', config);\n\nconst context: FabricationContext = {\n    input: {\n        value: \"Value given from outside\"\n    }\n}\n\nconsole.log(generator.generate(context));\n</code></pre> <p>Output</p> <pre><code>Value given from outside\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'context-input',\n            config: {\n                path: 'input.value',\n                sep: '.'\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconst context: FabricationContext = {\n    input: {\n        value: \"Value given from outside\"\n    }\n}\n\nconsole.log(fabricator.generate(context));\n</code></pre> <p>Output</p> <pre><code>{ value: 'Value given from outside' }\n</code></pre>"},{"location":"System-Documentation/Generators/08_constants/","title":"Constant Generator","text":"<p>This generator simply generates a deep copy of the value specified in the configuration.</p> <p>As the given value in the configuration, you can use whatever value you need - string, number, array, object, array of objects, undefined or null.</p>"},{"location":"System-Documentation/Generators/08_constants/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: ConstantValueConfig = {\n    value: 'my constant value'\n}\n\nconst generator = new ConstantValue(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'my constant value'\n</code></pre> <pre><code>const config: ConstantValueConfig = {\n    value: 'my constant value'\n}\n\nconst generator = getValueGenerator('constant-value', config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'my constant value'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'constant-value',\n            config: {\n                value: 'my constant value'\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'my constant value' }\n</code></pre>"},{"location":"System-Documentation/Generators/09_ip_addresses/","title":"IP Address Generator","text":"<p>This generator is responsible for generating random IP Address (v4) in a given range per each octet.</p>"},{"location":"System-Documentation/Generators/09_ip_addresses/#configuration","title":"Configuration","text":"<p>Example</p> <pre><code>const config: IPAddressConfig = {\n  octet1: { min: 10, max: 12 },\n  octet2: { min: 1, max: 32 },\n  octet3: { min: 1, max: 254 },\n  octet4: { min: 1, max: 254 },\n};\n</code></pre>"},{"location":"System-Documentation/Generators/09_ip_addresses/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const config: IPAddressConfig = {\n    octet1: { min: 10, max: 12 },\n    octet2: { min: 1, max: 32 },\n    octet3: { min: 1, max: 254 },\n    octet4: { min: 1, max: 254 }\n}\n\nconst generator = new IPAddressValueGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'12.16.131.227'\n</code></pre> <pre><code>const config: IPAddressConfig = {\n    octet1: { min: 10, max: 12 },\n    octet2: { min: 1, max: 32 },\n    octet3: { min: 1, max: 254 },\n    octet4: { min: 1, max: 254 }\n}\n\nconst generator = getValueGenerator('ip-address', config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'12.16.131.227'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'ip-address',\n            config: {\n                octet1: { min: 10, max: 12 },\n                octet2: { min: 1, max: 32 },\n                octet3: { min: 1, max: 254 },\n                octet4: { min: 1, max: 254 }\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: '12.16.131.227' }\n</code></pre>"},{"location":"System-Documentation/Generators/99_others/","title":"Other Generators","text":"<p>These generators are providing services of generating values in very different manner and can't be easily categorized as others.</p>"},{"location":"System-Documentation/Generators/99_others/#xor-generator","title":"XOR Generator","text":"<p>This type of generator chooses between given Value Generators and selects one randomly to generate the result value while others remain idle.</p>"},{"location":"System-Documentation/Generators/99_others/#examples","title":"Examples","text":"<p>In the following examples, there is this probabilistic decision on if the generated value shall be <code>0</code> or <code>1</code>. This XOR Generator then automatically triggers one Constant Value Generator or another.</p> Instance accessDeclarative accessSchema access <pre><code>const config: XORConfiguration = {\n  generators: {\n    zero: { type: 'constant-value', config: { value: 0 } },\n    one: { type: 'constant-value', config: { value: 1 } },\n  }\n}\n\nconst generator = new XORGenerator(config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>1\n</code></pre> <pre><code>const config: XORConfiguration = {\n  generators: {\n    zero: { type: 'constant-value', config: { value: 0 } },\n    one: { type: 'constant-value', config: { value: 1 } },\n  }\n}\n\nconst generator = getValueGenerator('xor', config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>1\n</code></pre> <pre><code>const schema: SchemaInput = {\n  fields: {\n    value: {\n      type: 'xor',\n      config: {\n        generators: {\n          zero: { type: 'constant-value', config: { value: 0 } },\n          one: { type: 'constant-value', config: { value: 1 } }\n        }\n      }\n    }\n  }\n};\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 1 }\n</code></pre>"},{"location":"System-Documentation/Nullability/00_nullability/","title":"Nullability Configuration","text":"<p>Nullability is a feature for enabling the client to specify to the Value Generator to include  null-like values instead of the specified ones - on demand. </p>"},{"location":"System-Documentation/Nullability/00_nullability/#configuration","title":"Configuration","text":"<p>The configuration is based on description of how often should the null-like value occur in the generated dataset and what actual null-like value should be used.</p> <pre><code>const nullabilityConfiguration: NullabilityConfiguration = {\n  probability: 0.73,\n  nullValue: undefined,\n};\n</code></pre> <p>This configuration describes the used Value Generator should generate 73% of values and the rest 27% to be <code>undefined</code>. The <code>probability</code> has to be in a range <code>[0, 1]</code> - otherwise it throws an error. The <code>nullValue</code> should be <code>null</code> or <code>undefined</code>.</p>"},{"location":"System-Documentation/Nullability/00_nullability/#how-to-use-nullability","title":"How to use Nullability","text":"<p>This is an example how you can implement the nullability into your Schemas.</p> <p>Using with Value Generator</p> <pre><code>const config: ConstantValueConfig = {\n    value: \"my constant value\",\n    nullability: {\n        probability: 0.5,\n        nullValue: undefined\n    }\n};\n\nconst generator = getValueGenerator('constant-value', config);\n\nfor (let i = 0; i &lt; 10; i++) {\n    console.log(generator.generate());\n}\n</code></pre> <p>Output</p> <pre><code>undefined\nundefined\nundefined\n'my constant value'\nundefined\n'my constant value'\nundefined\n'my constant value'\n'my constant value'\n'my constant value'\n</code></pre> <p>This configuration is optional. When you do not provide it, the generated values won't include any specified not-null values.</p>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/","title":"Introduction","text":"<p>Falsum Pipes are Pipes transforming the generated falsum into another form.</p> <p>They usually have an influence on the whole falsum object and are populating these changes in depth (possibly nested fields).</p>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/#what-really-falsum-pipes-are","title":"What really Falsum Pipes are","text":"<p>Falsum Pipe is technically a function taking the given Falsum (as an object) and truning it into another object (usually Object, but can be used for object or array reductions).</p> <p>In the two following examples, you can see what Falsum Pipe might look like. At both of them, you can see they can be very simple but very powerful.</p> Plain exampleExample with Falbricate <pre><code>// Let's imagine this is a result of the fabrication\nconst falsum: Falsum = {\n  username: 'my-test-username',\n  email: 'email@example.com'\n}\n\n// Define your Falsum Pipe\nconst falsumPipe = (value: any) =&gt; JSON.stringify(value);\n\nconsole.log(falsumPipe(falsum));\n</code></pre> <p>Output</p> <pre><code>'{\"username\":\"my-test-username\",\"email\":\"email@example.com\"}'\n</code></pre> <pre><code>// Let's imagine this is a result of the fabrication\nconst falsum: Falsum = {\n  username: 'my-test-username',\n  email: 'email@example.com'\n}\n\n// Find the Falsum Pipe by name\nconst falsumPipe = getFalsumPipe('stringify');\n\nconsole.log(falsumPipe(falsum));\n</code></pre> <p>Output</p> <pre><code>'{\"username\":\"my-test-username\",\"email\":\"email@example.com\"}'\n</code></pre>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/#how-to-use-falsum-pipes","title":"How to use Falsum Pipes","text":"<p>Falsum Pipes are meant to be used as a part of the Schema Input, alongside with the fields declaration. The existence of an array containing these Falsum Pipes makes the Fabricator to pipe the generated falsum through - just before it's returned as fabrication result.</p> <p>Schema Input with Pipes</p> <pre><code>const schema: SchemaInput = {\n    fields: {\n        // Fields declaration in here\n    },\n    pipes: [\n        // Falsum Pipes declaration\n    ],\n}\n</code></pre> <p>Note</p> <p>Falsum Pipes declaration in the Schema Input is optional; when not provided, the Fabricator just returns what was generated - without any modifications.</p> <p>However, when specified, keep in mind it needs to be an <code>array</code>.</p> <p>As seen above, there is an internal registry for Falsum Pipes, so you can easily access them by providing the name. You can also pass a function as a Falsum Pipe (more in Custom Falsum Pipes).</p> <p>Keeping this design in mind, you can use it to modify the whole result Falsum (just before it's returned) as you wish. Have a look at the following example:</p> <p>Example of Schema Input with Falsum Pipes</p> <pre><code>const schema: SchemaInput = {\n  fields: {\n    randomUsername: {\n        type: 'string-of-length',\n        config: {\n            length: 13,\n            charset: 'abcdefghijklmnopqrstuvwxyz0123456789'.split('')\n        }\n    },\n    randomLanguages: {\n      type: 'array-sample',\n      config: {\n        array: ['JS/TS', 'Java', 'Python', 'C/C++', 'R', 'Rust'],\n        sampleSize: 3\n      }\n    }\n  },\n  pipes: [\n    'snake-case-props',     // Turns all property names from camelCase -&gt; snake_case\n    'stringify'             // Turns the whole Falsum into stringified form\n  ]\n}\n\nconst fabricator = new Fabricator(schema);\n\n// Result: '{\"random_username\":\"36l4rvo66rsia\",\"random_languages\":[\"Java\",\"Python\",\"R\"]}'\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>'{\"random_username\":\"l8wx3ml6k7wp3\",\"random_languages\":[\"C/C++\",\"Java\",\"Python\"]}'\n</code></pre> <p>Order matters!</p> <p>Order in which you declare the Falsum Pipes in the schema matters - result of the first one is being passed to the second one. Result from the second one is piped to the third one and so on....</p> <p>So - if you put them in wrong order, you might get in trouble very soon!</p>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/#custom-falsum-pipes","title":"Custom Falsum Pipes","text":"<p>You might find yourself in situation when you can't find any Falsum Pipe you would use. In this case, feel free to define your own.</p>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/#single-purpose-falsum-pipe","title":"Single-purpose Falsum Pipe","text":"<p>For some small single-purpose tasks, the easiest way might be to declare the pipe simply as a function and pass it to the schema.</p> <p>Single-purpose Falsum Pipe</p> <pre><code>const schema: SchemaInput = {\n  fields: {\n    randomUsername: {\n        type: 'string-of-length',\n        config: {\n            length: 13,\n            charset: 'abcdefghijklmnopqrstuvwxyz0123456789'.split('')\n        }\n    },\n    randomLanguages: {\n      type: 'array-sample',\n      config: {\n        array: ['JS/TS', 'Java', 'Python', 'C/C++', 'R', 'Rust'],\n        sampleSize: 3\n      }\n    }\n  },\n  pipes: [\n    (falsum: any) =&gt; JSON.stringify(falsum)\n  ]\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre>"},{"location":"System-Documentation/Pipes/Falsum-Pipes/00_falsum-pipes/#registration-of-custom-falsum-pipes","title":"Registration of Custom Falsum Pipes","text":"<p>For some repetetive tasks or when the pipe might be used more commonly, its better to register it into internal registry of Falsum Pipes.</p> <p>Registration of Custom Falsum Pipe</p> <pre><code>// Implement the Falsum Pipe\nconst myCustomFalsumPipe = (falsum: any) =&gt; {\n\n    // ...change something with the falsum...\n\n    return falsum\n}\n\n// Register the Falsum Pipe\nregisterFalsumPipe('my-custom-falsum-pipe', myCustomFalsumPipe);\n</code></pre> <p>Unique names</p> <p>Keep in mind the names needs to be unique - when there is one pipe with such name registered, it will throw an Error when trying to store!</p> <p>Naming conventions</p> <p>It doesn't matter what name do you use. As long as it's a string. But it's a best practice to avoid using whitespaces or special characters. Shouldn't stop working if you do, though...</p> <p>Now, when you have your custom pipe registered, you can use it in your schema by just referring to it by previously given name:</p> <p>Using custom pipes</p> <pre><code>const schema: SchemaInput = {\n  fields: {\n    randomUsername: {\n        type: 'string-of-length',\n        config: {\n            length: 13,\n            charset: 'abcdefghijklmnopqrstuvwxyz0123456789'.split('')\n        }\n    },\n    randomLanguages: {\n      type: 'array-sample',\n      config: {\n        array: ['JS/TS', 'Java', 'Python', 'C/C++', 'R', 'Rust'],\n        sampleSize: 3\n      }\n    }\n  },\n  pipes: [\n    'my-custom-falsum-pipe'\n  ]\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/","title":"Introduction","text":"<p>Value Pipes are functions responsible for modification of values generated by Value Generators.</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/#what-really-value-pipes-are","title":"What really Value Pipes are","text":"<p>Each Value Pipe can be described as this:</p> <pre><code>type ValuePipe = (value: GeneratedValue) =&gt; GeneratedValue;\n</code></pre> <p>Simply put, it's technically just a function performing a modification to the generated value.</p> <p>In other words, the Value pipe is only performing some post-generation modifications to the value. In the end, this modified value is then returned as the result of the Value Generator.</p> Plain exampleExample with FalbricateExample with Value GeneratorExample within Schema <pre><code>// Let's imagine this is a Generated value\nconst value = \"my testing value\";\n\n// Define your Value Pipe\nconst valuePipe = (value: string) =&gt; value.toUpperCase();\n\nconsole.log(valuePipe(value));\n</code></pre> <p>Output</p> <pre><code>'MY TESTING VALUE'\n</code></pre> <pre><code>// Let's imagine this is a Generated value\nconst value = \"my testing value\";\n\n// Find your Value Pipe\nconst valuePipe = getValuePipe('uppercase');\n\nconsole.log(valuePipe(value));\n</code></pre> <p>Output</p> <pre><code>'MY TESTING VALUE'\n</code></pre> <pre><code>const config: ConstantValueConfig = {\n    value: 'my testing value',\n    pipes: [\n        'uppercase'\n    ]\n}\n\nconst generator = getValueGenerator('constant-value', config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'MY TESTING VALUE'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'constant-value',\n            config: {\n                value: 'my testing value',\n                pipes: [\n                    'uppercase'\n                ]\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'MY TESTING VALUE' }\n</code></pre>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/#how-to-use-value-pipes","title":"How to use Value Pipes","text":"<p>Value Pipes are defined as a part of Value Generator configuration; just after the Value Generator creates the value, it checks there are any Value pipes defined and if so, it pipes it through all of them, one by one.</p> <p>Value Generator Configuration with Pipes</p> <pre><code>const generator = getValueGenerator('constant-value', {\n    // Fields required by the Value Generator you choose\n    value: 'my constant string',\n\n    // Value Pipes declaration\n    pipes: [\n        'uppercase',\n        'space-split'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>[ 'MY', 'CONSTANT', 'STRING' ]\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p> <p>Note</p> <p>Specifying the Value Pipes is optional. When none is provided, the Value Generator simply returns the value it generated.</p> <p>On the other hand, when you specify it, keep in mind that an <code>array</code> of functions is expected.</p> <p>As you can see above, the pipes can be organized into a one multistep pipeline updating the generated value</p> <p>Order matters</p> <p>Watch out! The order of the Value Pipes matter; when you don't keep this in mind, you can get into trouble very soon!</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/#custom-value-pipes","title":"Custom Value Pipes","text":"<p>You may easily find yourself in situation when you can't find any predefined Value Pipe doing what you need. Then, it would be nice to define your own custom pipe doing exactly what you need, right?</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/#single-purpose-value-pipe","title":"Single-purpose Value Pipe","text":"<p>As you can see above, the Value pipe is simply just a function taking a value and returning a modified one. No big deal.</p> <p>When you need, you can pass this to configuration of a Value Generator and it will try to use it.</p> <p>Single-purpose Value Pipe Example</p> <pre><code>const generator = getValueGenerator('constant-value', {\n    // Fields required by the Value Generator you choose\n    value: 'my constant string',\n\n    // Value Pipes declaration\n    pipes: [\n        (value: string) =&gt; value.toUpperCase()\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'MY CONSTANT STRING'\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/00_value-pipes/#registration-of-custom-value-pipes","title":"Registration of Custom Value Pipes","text":"<p>However, at some places, you might think that some functions are kind of repetetive and you need to use the very same at many places.</p> <p>For this reason, you can register your Value Pipe into the Falbricate internal ecosystem with a name assigned to it. Then, you only refer to your pipe just the same as you do to get some of the predefined ones.</p> <p>Registration of a Custom Value Pipe</p> <pre><code>const myPipe = (value: number) =&gt; {\n\n    // ... Do something with the given value ...\n    const newValue = value * 7\n\n    return newValue\n}\n\nregisterValuePipe('my-custom-value-pipe', myPipe);\n</code></pre> <p>Unique names</p> <p>Keep in mind the names has to be unique! When you try to use a name that is already reserved for another Value Pipe, it ends up in an Error!</p> <p>When you define your custom pipe, then you can use it anywhere you want.</p> <p>Using of a Custom Value Pipe</p> <pre><code>const config: ConstantValueGenerator = {\n    value: 4,\n    pipes: [\n        'my-custom-value-pipe'\n    ]\n}\n\nconst generator = getValueGenerator('constant-value', config);\n\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>28\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/01_casing/","title":"Casing Value Pipes","text":"<p>These pipes are used to change the casing of the characters.</p> <p>Note</p> <p>These pipes are only applicable on string inputs</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/01_casing/#uppercase-value-pipe","title":"Uppercase Value Pipe","text":"<p>This Value Pipe sets all the characters in the given value to uppercase.</p> Plain exampleExample with Value Generator <pre><code>const value = 'mY sTrInG';\n\nconst pipe = getValuePipe('uppercase');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>'MY STRING'\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: 'mY sTrInG',\n    pipes: [\n        'uppercase'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'MY STRING'\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/01_casing/#lowercase-value-pipe","title":"Lowercase Value Pipe","text":"<p>This Value Pipe sets all the characters in the given value to lowercase.</p> Plain exampleExample with Value Generator <pre><code>const value = 'mY sTrInG';\n\nconst pipe = getValuePipe('lowercase');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>'my string'\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: 'mY sTrInG',\n    pipes: [\n        'lowercase'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'my string'\n</code></pre> <p>Tip</p> <p>This example uses Constant String Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/02_string-cleaning/","title":"String Cleanup","text":"<p>These pipes are used to cleanup the given string values.</p> <p>Note</p> <p>These pipes are only applicable on string inputs</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/02_string-cleaning/#trim-value-pipe","title":"Trim Value Pipe","text":"<p>This value pipe removes all the leading and trailing whitespaces in the given string.</p> Plain exampleExample with Value Generator <pre><code>const value = '  my string\\t\\n';\n\nconst pipe = getValuePipe('trim');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>'my string'\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: '  my string\\t\\n',\n    pipes: [\n        'trim'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'my string'\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/02_string-cleaning/#single-space-value-pipe","title":"Single Space Value Pipe","text":"<p>This Value Pipe removes multiple spaces and turns them into a single one.</p> Plain exampleExample with Value Generator <pre><code>const value = 'my  string    with spaces';\n\nconst pipe = getValuePipe('single-space');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>'my string with spaces'\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: 'my  string    with spaces',\n    pipes: [\n        'single-space'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'my string with spaces'\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/03_sorting/","title":"Sorting","text":"<p>These pipes are used to sort the given value.</p> <p>Note</p> <p>These pipes are only applicable on array or string inputs</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/03_sorting/#sort-ascending","title":"Sort Ascending","text":"<p>This value pipe orders the given value in ascending order.</p> Plain exampleExample with Value Generator <pre><code>const value = ['b', 'x', 'a', 'm'];\n\nconst pipe = getValuePipe('sort-ascending');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>[ 'a', 'b', 'm', 'x' ]\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: ['b', 'x', 'a', 'm'],\n    pipes: [\n        'sort-ascending'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>[ 'a', 'b', 'm', 'x' ]\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/03_sorting/#sort-descending","title":"Sort Descending","text":"<p>This value pipe orders the given value in descending order.</p> Plain exampleExample with Value Generator <pre><code>const value = ['b', 'x', 'a', 'm'];\n\nconst pipe = getValuePipe('sort-descending');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>[ 'x', 'm', 'b', 'a' ]\n</code></pre> <pre><code>const generator = getValueGenerator('constant-value', {\n    value: ['b', 'x', 'a', 'm'],\n    pipes: [\n        'sort-descending'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>[ 'x', 'm', 'b', 'a' ]\n</code></pre> <p>Tip</p> <p>This example uses Constant Value Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/04_object-manipulation/","title":"Object Manipulation","text":"<p>These pipes are used to manipulate objects.</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/04_object-manipulation/#object-into-list","title":"Object into list","text":"<p>This value pipe turns the given object into a list.</p> Plain exampleExample with Value Generator <pre><code>const value = {\n    prop1: \"my prop value\",\n    prop2: \"my another prop value\"\n};\n\nconst pipe = getValuePipe('object-to-list');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>[\n    { key: 'prop1', value: 'my prop value' },\n    { key: 'prop2', value: 'my another prop value' }\n]\n</code></pre> <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        prop1: {\n            type: 'constant-value',\n            config: {\n                value: 'my prop value'\n            }\n        },\n        prop2: {\n            type: 'constant-value',\n            config: {\n                value: 'my another prop value'\n            }\n        }\n    }\n}\n\nconst generator = getValueGenerator('object-from-schema', {\n    schema: fieldSchema,\n    pipes: [\n        'object-to-list'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>[\n    { key: 'prop1', value: 'my prop value' },\n    { key: 'prop2', value: 'my another prop value' }\n]\n</code></pre> <p>Tip</p> <p>This example uses Object Generator. You may want to check it out </p>"},{"location":"System-Documentation/Pipes/Value-Pipes/05_stringify/","title":"Stringification","text":"<p>These pipes are used to stringify the given values.</p>"},{"location":"System-Documentation/Pipes/Value-Pipes/05_stringify/#plain-stringification","title":"Plain stringification","text":"<p>This value returns a string of the given value.</p> Plain exampleExample with Value Generator <pre><code>const value = {\n    prop1: \"my prop value\",\n    prop2: \"my another prop value\"\n};\n\nconst pipe = getValuePipe('stringify');\n\nconsole.log(pipe(value))\n</code></pre> <p>Output</p> <pre><code>'{\"prop1\":\"my prop value\",\"prop2\":\"my another prop value\"}'\n</code></pre> <pre><code>const fieldSchema: SchemaInput = {\n    fields: {\n        prop1: {\n            type: 'constant-value',\n            config: {\n                value: 'my prop value'\n            }\n        },\n        prop2: {\n            type: 'constant-value',\n            config: {\n                value: 'my another prop value'\n            }\n        }\n    }\n}\n\nconst generator = getValueGenerator('object-from-schema', {\n    schema: fieldSchema,\n    pipes: [\n        'stringify'\n    ]\n});\n\nconsole.log(generator.generate())\n</code></pre> <p>Output</p> <pre><code>'{\"prop1\":\"my prop value\",\"prop2\":\"my another prop value\"}'\n</code></pre> <p>Tip</p> <p>This example uses Object Generator. You may want to check it out </p>"},{"location":"System-Documentation/Profiles/00_introduction/","title":"Introduction","text":"<p>Profiles are predefined Fabricators used to pre-generate common fields to use it in the simplest possible manner.</p> <p>These prepared data objects are meant to be accessible through a context object provided to each Falsum Fabrication run. So, you can easily access them using context accessors without needing to declare these on your own.</p> <p>These are also meant to share pre-generated values for the falsum to remain internally consistent; e.g. person born in Germany will probably have german nationality, probably will have a telephone number starting with <code>+49</code> local prefix, main language will be german and first name will most likely be Hans.</p>"},{"location":"System-Documentation/Profiles/00_introduction/#schema-declaration","title":"Schema Declaration","text":"<p>To declare that you want to have access to a profile, you need to provide the profile's name into a Schema input like this:</p> <pre><code>const schemaInput: SchemaInput = {\n  // Declaration of profiles you want to use\n  profiles: ['identifiers'],\n\n  fields: {\n    // Field using the profile via the provided context\n    id: {\n      type: 'context-input',\n      config: {\n        path: 'profiles.identifiers.uuid',\n      },\n    },\n\n    // ... other fields ...\n  },\n};\n\nconst fabricator = new Fabricator(schemaInput);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ id: '5c3c2dc9-905b-4005-4059-40ff821cd2cc' }\n</code></pre> <p>Tip</p> <p>In this example, you can see a basic usage of Identifiers  profile for generating an object ID. Check it out!</p> <p>As you can see, the profile data are generated and passed into the Fabrication Context object into <code>profiles</code> property; the actual profile object (with its contents) you requested is then accessible under its name.</p>"},{"location":"System-Documentation/Profiles/01_identifiers/","title":"Identifiers","text":"<p>Identifiers are one of the most basic metadata properties of data. Instead of generating them on your own, you can use a predefined profile <code>identifiers</code>.</p>"},{"location":"System-Documentation/Profiles/01_identifiers/#example-usage","title":"Example Usage","text":"<p>At the following example you can see how could this profile:</p> <pre><code>const schemaInput: SchemaInput = {\n  // Declaration of profiles you want to use\n  profiles: ['identifiers'],\n\n  fields: {\n    // Field being scraped from a context using the reference notation\n    uuid: '!ref-profiles.identifiers.uuid'\n\n    // ... other fields ...\n  },\n};\n\nconst fabricator = new Fabricator(schemaInput);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ uuid: '5c3c2dc9-905b-4005-4059-40ff821cd2cc' }\n</code></pre>"},{"location":"System-Documentation/Profiles/01_identifiers/#contents","title":"Contents","text":"<p>There are more various identifiers than just uuid:</p> <ul> <li><code>rowNumber</code> - Number of the generated instance in a sequence    (only when using <code>generateMany(n)</code> method)</li> <li><code>randH</code> - Random number within hundreds (from interval [100 - 999])</li> <li><code>randT</code> - Random number within thousands (from interval [1,000 - 9,999])</li> <li><code>randM</code> - Random number within millions (from interval [1,000,000 - 9,999,999])</li> <li><code>uuid</code> - UUID (Universally Unique Identifier) in lowercase characters;    otherwise the value is the same as in <code>UUID</code> property </li> <li><code>UUID</code> - UUID (Universally Unique Identifier) in uppercase characters;   otherwise the value is the same as in <code>uuid</code> property</li> </ul>"},{"location":"System-Documentation/Profiles/01_identifiers/#example","title":"Example","text":"<p>Here's an example of how does the <code>identifiers</code> profile behave:</p> <pre><code>const schemaInput: SchemaInput = {\n  profiles: ['identifiers'],\n  fields: {\n    rowNumber: '!ref-profiles.identifiers.rowNumber',\n    randH: '!ref-profiles.identifiers.randH',\n    randT: '!ref-profiles.identifiers.randT',\n    randM: '!ref-profiles.identifiers.randM',\n    uuid: '!ref-profiles.identifiers.uuid',\n    UUID: '!ref-profiles.identifiers.UUID'\n  },\n};\n\nconst fabricator = new Fabricator(schemaInput);\n\nconsole.log(fabricator.generateMany(3));\n</code></pre> <p>Output</p> <pre><code>[\n    {\n        rowNumber: 0,\n        randH: 115,\n        randT: 5263,\n        randM: 3968364,\n        uuid: '23d8ec5f-93ea-4919-ce83-df638a958303',\n        UUID: '23D8EC5F-93EA-4919-CE83-DF638A958303'\n    },\n    {\n        rowNumber: 1,\n        randH: 649,\n        randT: 9368,\n        randM: 3201817,\n        uuid: '38360491-f11a-484c-24c8-61d00ba29aba',\n        UUID: '38360491-F11A-484C-24C8-61D00BA29ABA'\n    },\n    {\n        rowNumber: 2,\n        randH: 502,\n        randT: 2845,\n        randM: 5387946,\n        uuid: '9393d3fb-d23d-43bb-9bdb-9af99c5d942a',\n        UUID: '9393D3FB-D23D-43BB-9BDB-9AF99C5D942A'\n    }\n]\n</code></pre>"},{"location":"System-Documentation/Standards/00_introduction/","title":"Introduction","text":"<p>Standards are basically preconfigured Value Generators. Since such Standard Value Generators do not require any further configuration, their specification is much simpler.</p> <p>To describe to the Fabricator you want to use a specific standard value generator in your schema, you only need to attach the standard's name to the field.</p> <p>Example</p> <pre><code>const schema: SchemaInput = {\n    fields: {\n        myStandardField: 'some-standard-name',\n        myAnotherStandardField: 'some-another-standard-name',\n        onceMoreStandardField: 'some-different-standard-name',\n\n        // ... Some other desired fields ...\n    },\n\n    // ... Other configuration when desired ...\n};\n\nconst fabricator = new Fabricator(config);\n\nconsole.log(fabricator.generate());\n</code></pre>"},{"location":"System-Documentation/Standards/00_introduction/#motivation","title":"Motivation","text":"<p>The main two benefits of using Standard Value Generators are:</p> <ul> <li>Much simpler definition of common value types - much easier to read the schema declaration</li> <li>Much less repetition when using the very same value types - when you do not want to repeat the very   same field definition over many schemas - DRY Concept</li> </ul> <p>But to be fully transparent, there is one disadvantage - you can't configure it anymore. For example, when you want to use Value Pipes, you'll need to either define your own Custom Standard or to use plain Value Generator.</p>"},{"location":"System-Documentation/Standards/00_introduction/#structure","title":"Structure","text":"<p>In most cases, the Standard Value Generator are really just preconfigured Value Generators with default settings used in real world cases.</p> <p>For example UUID Standard is implemented as a preconfigured String Template Generator following the basic rules defined for UUIDs - how the result string should look like, what characters can it have at each position and so on.</p>"},{"location":"System-Documentation/Standards/00_introduction/#custom-standards","title":"Custom Standards","text":"<p>To create a custom Standard Value Generator, you need to prepare your desired configuration and a Value Generator to be sealed (can be a new one or an existing one).</p> <p>Example</p> <p>This is just a simple generator always returning a value <code>'Hello World!'</code> - nothing useful but can show the basics.</p> <pre><code>class HelloWorldStandard extends ConstantValue {\n  constructor(config: ValueGeneratorConfig) {\n    super({ ...config, value: \"Hello World!\" });\n  }\n}\n\n// This is technically the very same generator as any other.\n// Thus, feel free to use it in the very same manner as any other\nconst generator = new HelloWorldStandard();\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'Hello World!'\n</code></pre>"},{"location":"System-Documentation/Standards/00_introduction/#custom-standard-registration","title":"Custom Standard Registration","text":"<p>To register your Custom Standard into the Falbricate ecosystem, you need to provide a <code>StandardValueGeneratorBuilder</code> function. This is basically a function defined like this:</p> <pre><code>export type StandardValueGeneratorBuilder = () =&gt; StandardValueGenerator;\n</code></pre> <p>This means the builder function is just returning your Standard Value Generator on demand (on invocation). To actually perform the registration, pick a unique name and store it like this:</p> <pre><code>registerStandard('hello-world-standard', () =&gt; new HelloWorldStandard());\n</code></pre> <p>Unique Name</p> <p>Keep in mind the name is expected to be unique. When does your selected name colide with any other currently used name, the function will throw an error on this attempt.</p>"},{"location":"System-Documentation/Standards/00_introduction/#using-custom-standards","title":"Using Custom Standards","text":"<p>Then, you can use it as explained above:</p> <pre><code>const schema: SchemaInput = {\n  fields: {\n    myStandardField: 'hello-world-standard',\n  },\n};\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ myStandardField: 'Hello World!' }\n</code></pre>"},{"location":"System-Documentation/Standards/00_introduction/#full-example","title":"Full example","text":"<p>Now, to put it all together, it could look something like this:</p> <pre><code>class HelloWorldStandard extends ConstantValue {\n  constructor(config: ValueGeneratorConfig = {}) {\n    super({ ...config, value: 'Hello World!' });\n  }\n}\n\nregisterStandard('hello-world-standard', () =&gt; new HelloWorldStandard());\n\nconst schema: SchemaInput = {\n  fields: {\n    myStandardField: 'hello-world-standard',\n  },\n};\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ myStandardField: 'Hello World!' }\n</code></pre>"},{"location":"System-Documentation/Standards/01_uuid/","title":"UUID Standards","text":"<p>UUID (Universally unique identifier) is a type of unique label used through various computer systems (see more).</p> <p>These Standard Value Generators tries to support it in your Falsa to ease the whole process of generating falsum data.</p> <p>Warning</p> <p>Keep in mind this implementation does not aim on secure randoms; some collisions might possibly occur.</p>"},{"location":"System-Documentation/Standards/01_uuid/#uuid-standard","title":"<code>uuid</code> Standard","text":"<p>This is a basic Standard Value Generator providing a service of generating UUIDs. In this case, it generates them built of lowercase hexadecimal characters (for uppercase version, use <code>UUID</code> Standard).</p>"},{"location":"System-Documentation/Standards/01_uuid/#examples","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const generator = new UUIDGenerator();\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'fd1e9650-d9bc-43c9-3cf1-9b39449908a6'\n</code></pre> <pre><code>const generator = getStandard('uuid');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'fd1e9650-d9bc-43c9-3cf1-9b39449908a6'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'uuid'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'fd1e9650-d9bc-43c9-3cf1-9b39449908a6' }\n</code></pre>"},{"location":"System-Documentation/Standards/01_uuid/#uuid-standard_1","title":"<code>UUID</code> Standard","text":"<p>This Standard Value Generator generates UUIDs - similarly as <code>uuid</code> Standard, however the generated value is built of uppercase hexadecimal values.</p>"},{"location":"System-Documentation/Standards/01_uuid/#examples_1","title":"Examples","text":"Instance accessDeclarative accessSchema access <pre><code>const generator = new UUIDGenerator({ uppercase: true });\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'9364B9C8-4A89-429C-B224-C185DABC5619'\n</code></pre> <pre><code>const generator = getStandard('UUID');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>'9364B9C8-4A89-429C-B224-C185DABC5619'\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'UUID'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: '9364B9C8-4A89-429C-B224-C185DABC5619' }\n</code></pre>"},{"location":"System-Documentation/Standards/02_timestamps/","title":"Timestamps","text":"<p>Timestamps Standard Value Generators are simple generators providing a service of generating time-points in the past or in the future. You only need to specify the time range.</p> <p>And since this is an approach that might be very common and tends to be very repetetive, there's a set of standards you can use.</p>"},{"location":"System-Documentation/Standards/02_timestamps/#names","title":"Names","text":"<p>Naming convention for prepared ones is as follows:</p> <pre><code>&lt;&lt;type&gt;&gt;-&lt;&lt;direction&gt;&gt;-&lt;&lt;period-length&gt;&gt;&lt;&lt;time-unit&gt;&gt;\n</code></pre> <p>where:</p> <ul> <li><code>&lt;&lt;type&gt;&gt;</code> describes the type of the output value - if it should be a timestamp (number) or   a date. Available values are <code>timestamp</code> or <code>date</code></li> <li><code>&lt;&lt;direction&gt;&gt;</code> declares the direction in which the generated value shall be - in the future   or in the past. Available values are <code>past</code> and <code>future</code></li> <li><code>&lt;&lt;period-lenght&gt;&gt;</code> defines up to how long should be the timestamp from the current moment</li> <li> <p><code>&lt;&lt;unit&gt;&gt;</code> defines which unit shall be used; strongly related to the <code>&lt;&lt;period-lenght&gt;&gt;</code>.   Available values are:</p> </li> <li> <p><code>s</code> for seconds</p> </li> <li><code>m</code> for minutes</li> <li><code>h</code> for hours</li> <li><code>d</code> for days</li> <li><code>M</code> for months</li> <li><code>y</code> for years</li> </ul> <p>For example, you could use <code>'timestamp-past-15m'</code> which describes a generator returning a number representing a timestamp in past 15 minutes.</p> <p>There are also predefined time windows for past and future that have a time indent from the current moment.</p> <p>This follows this naming pattern:</p> <pre><code>&lt;&lt;type&gt;&gt;-&lt;&lt;unit&gt;&gt;-&lt;&lt;direction&gt;&gt;\n</code></pre> <p>where:</p> <ul> <li><code>&lt;&lt;type&gt;&gt;</code> describes the type of the output value - if it should be a timestamp (number) or   a date. Available values are <code>timestamp</code> or <code>date</code></li> <li><code>&lt;&lt;unit&gt;&gt;</code> describes the unit used; available values are <code>minute</code>, <code>hour</code>, <code>day</code>, <code>week</code>, <code>month</code>,   <code>year</code>, <code>decade</code> and <code>century</code></li> <li><code>&lt;&lt;direction&gt;&gt;</code> declares the direction in which the generated value shall be - in the future   or in the past. Available values are <code>before</code> and <code>after</code></li> </ul> <p>So, for example, you could define your field to have a timestamp from past in range of 14 days before now but also up to 7 days before by using this generator <code>timestamp-week-before</code>.</p>"},{"location":"System-Documentation/Standards/02_timestamps/#timestamp-standards","title":"Timestamp Standards","text":"<p>Standards of this type are generating a timestamp represented by a number (UNIX timestamp).</p>"},{"location":"System-Documentation/Standards/02_timestamps/#examples","title":"Examples","text":"Declarative accessSchema access <pre><code>const generator = getStandard('timestamp-past-12h');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>1711865758409\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'timestamp-past-12h'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 1711865758409 }\n</code></pre>"},{"location":"System-Documentation/Standards/02_timestamps/#date-standards","title":"Date Standards","text":"<p>Similarly to Timestamp Standards, these generate a date based on the time-range specification. The difference is that the result value is a date.</p>"},{"location":"System-Documentation/Standards/02_timestamps/#examples_1","title":"Examples","text":"Declarative accessSchema access <pre><code>const generator = getStandard('date-past-12h');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>2024-03-31T06:15:58.409Z\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'date-past-12h'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 2024-03-31T06:15:58.409Z }\n</code></pre>"},{"location":"System-Documentation/Standards/03_booleans/","title":"Boolean Standards","text":"<p>Boolean Standard Value Generators enables you to use predefined value generators for boolean values.</p> <p>You can use any of the predefined standards from one of these groups:</p> <ul> <li> <p><code>boolean</code> - generates a random boolean, while the probability   for being <code>true</code> is <code>0.5</code> (in about a half examples, the value will   be <code>true</code>, in another half it will be <code>false</code>)</p> </li> <li> <p><code>true</code> and <code>false</code> - will generate a static constant boolean value</p> </li> <li> <p><code>boolean-&lt;&lt;probability&gt;&gt;</code> - lets you generate a boolean value with   specification of how probable the value should be <code>true</code>. Predefined   probabilities are [<code>0.1</code>, <code>0.2</code>, <code>0.25</code>, <code>0.3</code>, <code>0.4</code>, <code>0.5</code>, <code>0.6</code>,   <code>0.7</code>, <code>0.75</code>, <code>0.8</code> and <code>0.9</code>]. The result name could be for example   <code>boolean-0.75</code> (about one quarter of the values will be <code>false</code>, rest   will be <code>true</code>)</p> </li> </ul>"},{"location":"System-Documentation/Standards/03_booleans/#examples","title":"Examples","text":"Declarative accessSchema access <pre><code>const generator = getStandard('boolean-0.3');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>false\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'boolean-0.3'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: false }\n</code></pre>"},{"location":"System-Documentation/Standards/04_integers/","title":"Integer Standards","text":"<p>Integer Standard Value Generators lets you generate random integers by a predefined ranges.</p> <p>There are two general declaration patterns; both derived from logarithmic (base=10) notation:</p> <ul> <li> <p><code>integer-e&lt;&lt;base&gt;&gt;</code> - generates a random number within a range.   You can declare you want a number in scale of hundreds by using <code>2</code>   as base (<code>integer-e2</code>); the full list of available bases is:   [<code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>]. Note this range includes   also negative numbers.</p> </li> <li> <p><code>integer-e&lt;&lt;base&gt;&gt;-u</code> - similar to the <code>integer-e&lt;&lt;base&gt;&gt;</code> pattern;   by adding the <code>-u</code> flag, you specify the generated number has to be   a positive number.</p> </li> </ul>"},{"location":"System-Documentation/Standards/04_integers/#examples","title":"Examples","text":""},{"location":"System-Documentation/Standards/04_integers/#signed","title":"Signed","text":"<p>This is an example of the <code>integer-e&lt;&lt;base&gt;&gt;</code> pattern, where you want to get any number within the range with possible negative numbers.</p> Declarative accessSchema access <pre><code>const generator = getStandard('integer-e4');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>-8405\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'integer-e4'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: -8405 }\n</code></pre>"},{"location":"System-Documentation/Standards/04_integers/#unsigned","title":"Unsigned","text":"<p>This is an example of <code>integer-e&lt;&lt;base&gt;&gt;-u</code> pattern where you want to restrict the numbers to be within a range of <code>[0, random * (10 ^ base)]</code>.</p> Declarative accessSchema access <pre><code>const generator = getStandard('integer-e4-u');\nconsole.log(generator.generate());\n</code></pre> <p>Output</p> <pre><code>7828\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: 'integer-e4-u'\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 7828 }\n</code></pre>"},{"location":"System-Documentation/Standards/99_context-accessing/","title":"Context Accessing Shortcut","text":"<p>To simplify the context accessing and its definition, there's a shortcut notation defined. This type of declaration was chosen to enable simplicity of the schema definition based on more dynamic schema compilation approach.</p> <p>Instead of somewhat statically typed names of standards, this approach lets you pass configuration as a part of the name to your Field declaration.</p> <p>This notation is based on two parts - <code>!ref-&lt;&lt;path&gt;&gt;</code>, where the <code>&lt;&lt;path&gt;&gt;</code> is the path in the given context object using dots (<code>.</code>) as separators.</p> <p>Example</p> <p>In this example, you can see how you can access the desired value by specifying the path through the Fabrication Context object.</p> <pre><code>const context = {\n    myField: {\n        myValue: 'some-value'\n    }\n};\n\nconst valueGenerator = getStandard('!ref-myField.myValue');\n\nconst generatedValue = valueGenerator.generate(context);\n</code></pre> <p>Output</p> <pre><code>'some-value'\n</code></pre> <p>Here's a full demonstration of how the shortcut can be used:</p> <p>Example</p> <p>You can declare your schema with usage of identifiers profile. This profile passes pregenerated values into a context object accessible to each value generator, so you can easily access it.</p> <p>You can also specify other fields; in this case <code>addressId</code> field - to take a value from given context object passed during the fabrication. This can be useful for example when you are generating instances of multiple entities linked by foreign keys.</p> <pre><code>// Declare your schema\nconst schema: SchemaInput = {\n  profiles: ['identifiers'],\n  fields: {\n    userId: '!ref-profiles.identifiers.uuid',\n    addressId: '!ref-addressId',\n\n    // ... another fields ...\n  }\n};\n\n// Create a Fabricator instance\nconst fabricator = new Fabricator(schema);\n\n// Generate a Falsum object with specified context\nconst generated: Falsum = fabricator.generate({\n  addressId: 123456\n});\n\nconsole.log(generated);\n</code></pre> <p>Output</p> <pre><code>{ userId: 'f85d6bc3-1391-488b-90ad-8a114d1be5be', addressId: 123456 }\n</code></pre>"},{"location":"Utils/charset/","title":"Charsets","text":"<p>Charset defines an alphabet that can be used; mostly for generating structured strings. In Falbricate ecosystem,  charset is basically an array of single-character strings.</p>"},{"location":"Utils/charset/#predefined-charsets","title":"Predefined charsets","text":"<p>There is already a set of charsets prepared for easier use:</p> <ul> <li><code>numbers</code> (from interval <code>[0, 9]</code>)</li> <li><code>lowercase</code> (<code>[a-z]</code>)</li> <li><code>uppercase</code> (<code>[A-Z]</code>)</li> <li><code>specials</code> (some of the special characters, like any of these: <code>.,-?!:_$#&amp;@=+-;*~/\\|'\"</code>)</li> <li><code>doubles</code> (double characters, like parentheses, brackets and so on)</li> <li><code>hexlower</code> (hexadecimal characters in lowercases)</li> <li><code>hexupper</code> (hexadecimal characters in uppercases)</li> <li><code>letters</code> (upper- and lowercase letters)</li> <li><code>alphanum</code> (uppercases, lowercases and numbers)</li> <li><code>alphanumspecs</code> (uppercases, lowercases, numbers and special characters)</li> </ul>"},{"location":"Utils/charset/#using-charsets","title":"Using charsets","text":"<p>Predefined charsets can be used at wide range of places through the Falbricate ecosystem, however the most common use-case is definitely when generating strings.</p> <p>To demonstrate the usage, let's use the String of length  Value Generator.</p>"},{"location":"Utils/charset/#examples","title":"Examples","text":"<p>Here you can compare using predefined charsets with explicit declaration</p> Explicit definitionPredefined charsets <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'string-of-length',\n            config: {\n                length: 13,\n\n                // Normally, to define the lowercase hexadecimal characters,\n                // you would need to define the whole array of them\n                charset: [\n                    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', \n                    'a', 'b', 'c', 'd', 'e', 'f'\n                ]\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'd25a5e750566b' }\n</code></pre> <pre><code>const schema: SchemaInput = {\n    fields: {\n        value: {\n            type: 'string-of-length',\n            config: {\n                length: 13,\n\n                // Now, you only need to specify the charset name\n                charset: 'hexlower'\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ value: 'd25a5e750566b' }\n</code></pre>"},{"location":"Utils/charset/#custom-charsets","title":"Custom charsets","text":"<p>If your application requires a specific set of characters, you are free to define your own that meets the requirements.</p>"},{"location":"Utils/charset/#example","title":"Example","text":"<p>To define such charset, you only need to register it into the Falbricate ecosystem with following snippet:</p> <pre><code>registerCharset('my-custom-characters', ['x', 'y', 'z', '3']);\n</code></pre> <p>Now, let's see the whole example:</p> <p>Example</p> <pre><code>// Registration of my custom charset\nregisterCharset('my-custom-characters', ['x', 'y', 'z', '3']);\n\n// Definition of schema using such charset\nconst schema: SchemaInput = {\n    fields: {\n        mySpecialString: {\n            type: 'string-of-length',\n            config: {\n                length: 5,\n\n                // Now, define using your charset \n                charset: 'my-custom-characters'\n            }\n        }\n    }\n}\n\nconst fabricator = new Fabricator(schema);\n\nconsole.log(fabricator.generate());\n</code></pre> <p>Output</p> <pre><code>{ mySpecialString: 'y3zzx' }\n</code></pre> <p>Note</p> <p>There are some requirements your custom charset must meet:</p> <ul> <li> <p>Unique naming convention - name you specify must be unique through the whole   ecosystem</p> </li> <li> <p>Given charset must be a charset - the charset (as specified above) is considered   to be an array of single-character strings; nothing else is allowed.</p> </li> </ul>"},{"location":"Utils/randomizer/","title":"Randomizer","text":"<p>By default, Falbricate uses default JavaScript <code>Math.random</code> for generating random values. For some cases, this might not be desired; sometimes you might want to use something  cryptographically more secure.</p>"},{"location":"Utils/randomizer/#predefined-generators","title":"Predefined generators","text":"<p>There are currently set these generators:</p> <ul> <li> <p><code>default</code> - using native JavaScript implementation (<code>Math.random</code>) for random floats    within <code>[0, 1]</code> interval generation.</p> </li> <li> <p><code>crypto</code> - using Node.js' <code>crypto</code> library for generation of more cryptographically    secure randoms</p> </li> </ul> <p>To specify you want to use a different generator, you need to specify it using <code>useRandomizer(name: string)</code> function:</p> <p>Example</p> <pre><code>useRandomizer('crypto')\n</code></pre>"},{"location":"Utils/randomizer/#what-is-a-randomizer","title":"What is a randomizer","text":"<p>For Falbricate, randomizer (or Random Generator) is a function providing a pseudo-random  number in range <code>[0, 1]</code> and is being used all over the Falbricate ecosystem. For example  the default randomizer is simply the default <code>Math.random</code> function.</p>"},{"location":"Utils/randomizer/#seeded-randomizer","title":"Seeded randomizer","text":"<p>In some scenarios, you might need to use not exactly random values, but seeded randoms - to be able to determinate the results.</p> <p>For this purpose, there's a simple implementation of Linear Congruential Generator (LCG) defined.</p> <p>To enable this feature, you need to start with:</p> <pre><code>useSeed(123)\n</code></pre> <p>This will make sure your Fabricators will generate pseudo-random results with a deterministic element - results shall be always the same. This feature might be very useful for extensive testing purposes.</p>"},{"location":"Utils/randomizer/#custom-generators","title":"Custom generators","text":"<p>You may find yourself in a situation when you need to implement your own generator. For this purpose, you need to define your random-generator function and register it into the Falbricate ecosystem.</p> <pre><code>const randomizer = () =&gt; 0.12345;\n\nstoreRandomizer('my-randomizer', randomizer);\n\nuseRandomizer('my-randomizer');\n</code></pre>"}]}